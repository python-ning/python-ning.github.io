<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>python ning&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://python-ning.github.io/"/>
  <updated>2016-07-28T22:01:45.000Z</updated>
  <id>http://python-ning.github.io/</id>
  
  <author>
    <name>python-ning</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis的安装与配置</title>
    <link href="http://python-ning.github.io/2016/07/28/redis_install_config/"/>
    <id>http://python-ning.github.io/2016/07/28/redis_install_config/</id>
    <published>2016-07-28T07:00:00.000Z</published>
    <updated>2016-07-28T22:01:45.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jianyan.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;有时间了，就看了看 redis，大概说一下 redis 的安装和配置，以及配置的各个参数的含义&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;redis 官网&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://redis.io/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.进入&lt;a href=&quot;http://redis.io/download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://redis.io/download&lt;/a&gt; 下载页，下面有命令，wget 下载下来，或者直接下载压缩文件&lt;br&gt;2.解压压缩文件，打开解压后的文件夹，运行&lt;code style=&quot;color:red&quot;&gt;make&lt;/code&gt;,可再运行 &lt;code style=&quot;color:red&quot;&gt;make test&lt;/code&gt; 测试是否安装正确&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget http://download.redis.io/releases/redis-3.2.1.tar.gz
$ tar xzf redis-3.2.1.tar.gz
$ cd redis-3.2.1
$ make
$ make test
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.启动服务端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ src/redis-server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.启动客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ src/redis-cli
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.终端出现以下形式，说明已经进入 redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;p&gt;获取配置文件信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CONFIG GET *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你要改配置文件，可以直接去修改 redis.cnf，或者在终端里直接一条一条修改，比如下面是修改 redis 权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CONFIG SET requirepass password
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;配置参数含义&quot;&gt;&lt;a href=&quot;#配置参数含义&quot; class=&quot;headerlink&quot; title=&quot;配置参数含义&quot;&gt;&lt;/a&gt;配置参数含义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程&lt;/p&gt;
&lt;p&gt; daemonize no&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定&lt;/p&gt;
&lt;p&gt; pidfile /var/run/redis.pid&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字&lt;/p&gt;
&lt;p&gt; port 6379&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绑定的主机地址&lt;/p&gt;
&lt;p&gt; bind 127.0.0.1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timeout 300
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;/p&gt;
&lt;p&gt; loglevel verbose&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null&lt;/p&gt;
&lt;p&gt; logfile stdout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id&lt;/dbid&gt;&lt;/p&gt;
&lt;p&gt; databases 16&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合&lt;/p&gt;
&lt;p&gt; save &lt;seconds&gt; &lt;changes&gt;&lt;/changes&gt;&lt;/seconds&gt;&lt;/p&gt;
&lt;p&gt; Redis默认配置文件中提供了三个条件：&lt;/p&gt;
&lt;p&gt; save 900 1&lt;/p&gt;
&lt;p&gt; save 300 10&lt;/p&gt;
&lt;p&gt; save 60 10000&lt;/p&gt;
&lt;p&gt; 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大&lt;/p&gt;
&lt;p&gt;rdbcompression yes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定本地数据库文件名，默认值为dump.rdb&lt;/p&gt;
&lt;p&gt;dbfilename dump.rdb&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定本地数据库存放目录&lt;/p&gt;
&lt;p&gt;dir ./&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;/p&gt;
&lt;p&gt;slaveof &lt;masterip&gt; &lt;masterport&gt;&lt;/masterport&gt;&lt;/masterip&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当master服务设置了密码保护时，slav服务连接master的密码&lt;/p&gt;
&lt;p&gt;masterauth &lt;master-password&gt;&lt;/master-password&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭&lt;/password&gt;&lt;/p&gt;
&lt;p&gt;requirepass foobared&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;/p&gt;
&lt;p&gt;maxclients 128&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区&lt;/p&gt;
&lt;p&gt;maxmemory &lt;bytes&gt;&lt;/bytes&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no&lt;/p&gt;
&lt;p&gt;appendonly no&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定更新日志文件名，默认为appendonly.aof&lt;/p&gt;
&lt;p&gt; appendfilename appendonly.aof&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定更新日志条件，共有3个可选值：&lt;br&gt;no：表示等操作系统进行数据缓存同步到磁盘（快）&lt;br&gt;always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）&lt;br&gt;everysec：表示每秒同步一次（折衷，默认值）&lt;/p&gt;
&lt;p&gt;appendfsync everysec&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）&lt;/p&gt;
&lt;p&gt; vm-enabled no&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享&lt;/p&gt;
&lt;p&gt; vm-swap-file /tmp/redis.swap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0&lt;/p&gt;
&lt;p&gt; vm-max-memory 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值&lt;/p&gt;
&lt;p&gt; vm-page-size 32&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。&lt;/p&gt;
&lt;p&gt; vm-pages 134217728&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4&lt;/p&gt;
&lt;p&gt; vm-max-threads 4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启&lt;/p&gt;
&lt;p&gt;glueoutputbuf yes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法&lt;/p&gt;
&lt;p&gt;hash-max-zipmap-entries 64&lt;/p&gt;
&lt;p&gt;hash-max-zipmap-value 512&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）&lt;/p&gt;
&lt;p&gt;activerehashing yes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件&lt;/p&gt;
&lt;p&gt;include /path/to/local.conf&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jianyan.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;有时间了，就看了看 red
    
    </summary>
    
      <category term="redis" scheme="http://python-ning.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://python-ning.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>jira的安装配置以及接口调用</title>
    <link href="http://python-ning.github.io/2016/07/16/jira_python_api/"/>
    <id>http://python-ning.github.io/2016/07/16/jira_python_api/</id>
    <published>2016-07-16T07:00:00.000Z</published>
    <updated>2016-07-16T21:09:56.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/55e736d12f2eb9388e9d2280d4628535e4dd6fcb.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近应用户的需求，使用了一下 jira这个软件，用户要用 jira 作为工作流使用来调用私有云的云资源&lt;/p&gt;
&lt;h3 id=&quot;jira-介绍&quot;&gt;&lt;a href=&quot;#jira-介绍&quot; class=&quot;headerlink&quot; title=&quot;jira 介绍&quot;&gt;&lt;/a&gt;jira 介绍&lt;/h3&gt;&lt;p&gt;JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。&lt;br&gt;JIRA中配置灵活、功能全面、部署简单、扩展丰富，其超过150项特性得到了全球115个国家超过19,000家客户的认可。&lt;/p&gt;
&lt;h3 id=&quot;jira-安装与配置&quot;&gt;&lt;a href=&quot;#jira-安装与配置&quot; class=&quot;headerlink&quot; title=&quot;jira 安装与配置&quot;&gt;&lt;/a&gt;jira 安装与配置&lt;/h3&gt;&lt;h2 id=&quot;jira官网地址&quot;&gt;&lt;a href=&quot;#jira官网地址&quot; class=&quot;headerlink&quot; title=&quot;jira官网地址&quot;&gt;&lt;/a&gt;jira官网地址&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://www.atlassian.com/software/jira
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;jira帐号注册地址&quot;&gt;&lt;a href=&quot;#jira帐号注册地址&quot; class=&quot;headerlink&quot; title=&quot;jira帐号注册地址:&quot;&gt;&lt;/a&gt;jira帐号注册地址:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://id.atlassian.com/signup
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;jira激活地址&quot;&gt;&lt;a href=&quot;#jira激活地址&quot; class=&quot;headerlink&quot; title=&quot;jira激活地址:&quot;&gt;&lt;/a&gt;jira激活地址:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://id.atlassian.com/login?application=mac&amp;amp;continue=https://my.atlassian.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.首先输入 jira 的官网地址，点击 Try it free进入试用界面&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira1.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;2.节点点击Try it free&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira1.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;3.注册 jira 的帐号，填写相关选项，确定&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira3.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;4.然后你会进入下面这个页面&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira4.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;5.你的邮箱会收到下面这个邮件，点击验证你的邮箱&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira5.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;6.验证完后就开始系统配置你的 jira 了，如下图&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira6.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;7.等页面变成一下就说明配置完了&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira7.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;8.然后进入jira 激活地址，登录（你的邮箱是帐号）到如下页面，点击红框里的按钮&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira8.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;9.进入以下网址，填写表单，（server id 是你 jira 安装到的主机上在设置里查到的）,然后确定&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira9.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;10.你就进入了下面的页面，拿到这个License Key，当你安装 jira 访问的时候他会提示你输入这个 key&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/jira10.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;jira-一些功能&quot;&gt;&lt;a href=&quot;#jira-一些功能&quot; class=&quot;headerlink&quot; title=&quot;jira 一些功能&quot;&gt;&lt;/a&gt;jira 一些功能&lt;/h3&gt;&lt;p&gt;jira 主要是做工作流，他可以设置工作流方案，自定义字段，很方便好用&lt;/p&gt;
&lt;h3 id=&quot;jira-私有云接口-flask&quot;&gt;&lt;a href=&quot;#jira-私有云接口-flask&quot; class=&quot;headerlink&quot; title=&quot;jira+私有云接口+flask&quot;&gt;&lt;/a&gt;jira+私有云接口+flask&lt;/h3&gt;&lt;p&gt;jira 有一个 webhooks 的东东，是发http 请求的，我通过触发某个按钮，带上操作云资源需要的参数（自定义字段），在 webhooks 指定接受请求的连接，这里是用 python 的 flask 框架来接收 jira 发送的请求，是带有 json 数据的一个post 请求，flask 通过接受到的参数，去做处理，调取私有云系统的 api 从而实现通过 jira 对私有云系统的部分操作。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/55e736d12f2eb9388e9d2280d4628535e4dd6fcb.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;ma
    
    </summary>
    
      <category term="jira" scheme="http://python-ning.github.io/categories/jira/"/>
    
    
      <category term="flask" scheme="http://python-ning.github.io/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>我的项目经验</title>
    <link href="http://python-ning.github.io/2016/06/28/ning.chen/"/>
    <id>http://python-ning.github.io/2016/06/28/ning.chen/</id>
    <published>2016-06-28T07:00:00.000Z</published>
    <updated>2016-06-29T20:46:17.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;私有云项目&quot;&gt;&lt;a href=&quot;#私有云项目&quot; class=&quot;headerlink&quot; title=&quot;私有云项目&quot;&gt;&lt;/a&gt;私有云项目&lt;/h3&gt;&lt;p&gt;客户有(北京王府井集团，国家电网，神州数码)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus1.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus2.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus3.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus4.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关代码&quot;&gt;&lt;a href=&quot;#相关代码&quot; class=&quot;headerlink&quot; title=&quot;相关代码&quot;&gt;&lt;/a&gt;相关代码&lt;/h3&gt;&lt;h2 id=&quot;前端页部分代码&quot;&gt;&lt;a href=&quot;#前端页部分代码&quot; class=&quot;headerlink&quot; title=&quot;前端页部分代码&quot;&gt;&lt;/a&gt;前端页部分代码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus5.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端部分代码&quot;&gt;&lt;a href=&quot;#后端部分代码&quot; class=&quot;headerlink&quot; title=&quot;后端部分代码&quot;&gt;&lt;/a&gt;后端部分代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;from django.contrib.auth.decorators import login_required
from django.shortcuts import render_to_response
from django.forms.models import model_to_dict, save_instance
from django.http import HttpResponse
from db.models import *
from db.apis import *
from db.joblistener import send_welcome_email_to_internal, send_welcome_email
from sysadmin.views import *
from sysadmin.forms import *
from django.template.context import RequestContext
from django.utils.translation import ugettext as _
from sysadmin.templatetags.tags import *
from nexus.util import encrypt_password


@login_required
@permit_require(&amp;apos;cloudserver_r&amp;apos;)
@db_cached_view
@active_navs(&amp;apos;cloud_server&amp;apos;, &amp;apos;cloud_server&amp;apos;)
def index(request):
    customer_list = User.objects.order_by(&amp;apos;customer_name&amp;apos;)
    physical_server = PhysicalServer.objects.filter(
        hyperviser__in=[&amp;quot;kvm&amp;quot;]).order_by(&amp;apos;host_name&amp;apos;)
    image_list = Image.objects.filter(status=&amp;quot;Ready&amp;quot;).order_by(&amp;apos;name&amp;apos;)
    data_center = DataCenter.objects.order_by(&amp;apos;name&amp;apos;)
    cluster_list = Cluster.objects.order_by(&amp;apos;name&amp;apos;)
    data = {
        &amp;apos;customer_list&amp;apos;: customer_list,
        &amp;apos;physical_server&amp;apos;: physical_server,
        &amp;apos;image_list&amp;apos;: image_list,
        &amp;apos;data_center_list&amp;apos;: data_center,
        &amp;apos;cluster_list&amp;apos;: cluster_list,
        &amp;apos;cpu_modes&amp;apos;: CPU_MODES,
    }
    return render(request, &amp;apos;sysadmin/cloud_server/cloud_server_list.html&amp;apos;, data)


@login_required
@permit_require(&amp;apos;cloudserver_r&amp;apos;)
@db_cached_view
def cloudservers_json(request):
    def query_fields(key_word):
        query = (Q(name__contains=key_word) |
                 Q(host_name__contains=key_word) |
                 Q(image__name__contains=key_word) |
                 Q(physical_server__host_name__contains=key_word) |
                 Q(user__customer_name__contains=key_word) |
                 Q(status__contains=key_word))
        return query

    def order_callback(qobj, column):
        sortable = {0: &amp;quot;name&amp;quot;,
                    1: &amp;quot;host_name&amp;quot;,
                    2: &amp;quot;user__customer_name&amp;quot;,
                    5: &amp;quot;status&amp;quot;,
                    6: &amp;quot;image__name&amp;quot;,
                    11: &amp;quot;created_at&amp;quot;
                    }
        order = sortable[0]
        if column in sortable:
            order = sortable[column]
        return qobj.order_by(order)

    data = generate_query_data(VirtualServer, request,
                               create_and_search_callback(query_fields),
                               order_callback, generate_vserver_list)
    return response_200(json.dumps(data))


def generate_vserver_list(vservers):
    ret = []
    for vserver in vservers:
        if vserver.bandwidth &amp;gt;= 0:
            bandwidth_str = vserver.bandwidth
        else:
            bandwidth_str = &amp;quot;&amp;amp;nbsp;&amp;quot;
        if vserver.physical_server:
            pserver_str = &amp;quot;&amp;lt;a href=\&amp;quot;/admin/server/show/%s\&amp;quot;&amp;gt;%s&amp;lt;/a&amp;gt;&amp;quot; % (
                vserver.physical_server.id, vserver.physical_server.host_name)
        else:
            pserver_str = &amp;quot;&amp;quot;
        user_content = &amp;quot;&amp;quot;
        if vserver.user:
            user_content = &amp;quot;&amp;lt;a href=\&amp;quot;/admin/customer/show/%s\&amp;quot;&amp;gt;%s&amp;lt;/a&amp;gt;&amp;quot; % (
                vserver.user.id, vserver.user.customer_name)

        ret.append([
            &amp;quot;&amp;lt;a data-id=\&amp;quot;%s\&amp;quot; href=\&amp;quot;/admin/cloudserver/show/%s\&amp;quot;&amp;gt;%s&amp;lt;/a&amp;gt;&amp;quot; % (
                vserver.id, vserver.id, vserver.name),
            vserver.host_name,
            user_content,
            vserver.ip_address_str(),
            pserver_str,
            &amp;quot;&amp;lt;div style=\&amp;quot;color: %s\&amp;quot;&amp;gt;%s&amp;lt;/div&amp;gt;&amp;quot; % (
                vstatus_color(vserver.status), _(vserver.status)),
            vserver.image.name,
            vserver.cpu,
            vserver.memory,
            vserver.disk,
            bandwidth_str,
            format_time(vserver.created_at)
        ])
    return ret


@login_required
@permit_require(&amp;apos;cloudserver_w&amp;apos;)
@log_action(action=&amp;quot;Create Cloud Server&amp;quot;, method=&amp;quot;POST&amp;quot;)
def create(request):
    form = VirtualServerForm(request.POST)
    form.fields[&amp;apos;network_type_name&amp;apos;].choices = get_network_type_names()
    if form.is_valid():
        vserver = create_virtual_server_from_form(request, form)
        id = vserver.id
        return render_json({&amp;apos;url&amp;apos;: reverse(&amp;apos;cloudserver_show&amp;apos;, kwargs={&amp;apos;id&amp;apos;: id})})
    return render_form_error(form)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;公有云项目&quot;&gt;&lt;a href=&quot;#公有云项目&quot; class=&quot;headerlink&quot; title=&quot;公有云项目&quot;&gt;&lt;/a&gt;公有云项目&lt;/h3&gt;&lt;p&gt;(公司主营，公有云管理平台，让客户对所有云计算资源以及存储进行一键化操作)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus6.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus7.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关代码-1&quot;&gt;&lt;a href=&quot;#相关代码-1&quot; class=&quot;headerlink&quot; title=&quot;相关代码&quot;&gt;&lt;/a&gt;相关代码&lt;/h3&gt;&lt;h2 id=&quot;前端页面部分代码&quot;&gt;&lt;a href=&quot;#前端页面部分代码&quot; class=&quot;headerlink&quot; title=&quot;前端页面部分代码&quot;&gt;&lt;/a&gt;前端页面部分代码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus9.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端部分代码-1&quot;&gt;&lt;a href=&quot;#后端部分代码-1&quot; class=&quot;headerlink&quot; title=&quot;后端部分代码&quot;&gt;&lt;/a&gt;后端部分代码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus10.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;官网接口文档编写与测试&quot;&gt;&lt;a href=&quot;#官网接口文档编写与测试&quot; class=&quot;headerlink&quot; title=&quot;官网接口文档编写与测试&quot;&gt;&lt;/a&gt;官网接口文档编写与测试&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus8.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象存储-object-storage-相关技术&quot;&gt;&lt;a href=&quot;#对象存储-object-storage-相关技术&quot; class=&quot;headerlink&quot; title=&quot;对象存储(object_storage)相关技术&quot;&gt;&lt;/a&gt;对象存储(object_storage)相关技术&lt;/h3&gt;&lt;p&gt;客户(当当网、民族证券)&lt;/p&gt;
&lt;h2 id=&quot;对象存储-object-storage&quot;&gt;&lt;a href=&quot;#对象存储-object-storage&quot; class=&quot;headerlink&quot; title=&quot;对象存储(object_storage)&quot;&gt;&lt;/a&gt;对象存储(object_storage)&lt;/h2&gt;&lt;p&gt;Python相关代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/nexus11.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;私有云项目&quot;&gt;&lt;a href=&quot;#私有云项目&quot; class=&quot;headerlink&quot; title=&quot;私有云项目&quot;&gt;&lt;/a&gt;私有云项目&lt;/h3&gt;&lt;p&gt;客户有(北京王府井集团，国家电网，神州数码)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1
    
    </summary>
    
      <category term="求职" scheme="http://python-ning.github.io/categories/%E6%B1%82%E8%81%8C/"/>
    
    
      <category term="求职" scheme="http://python-ning.github.io/tags/%E6%B1%82%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>python面试题精选</title>
    <link href="http://python-ning.github.io/2016/06/27/python_interview_questions/"/>
    <id>http://python-ning.github.io/2016/06/27/python_interview_questions/</id>
    <published>2016-06-27T07:00:00.000Z</published>
    <updated>2016-07-01T18:10:53.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/293387-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;小癖好~爱做面试题，感觉每次做份面试题总能在其中复习了很多基础知识和一些算法~&lt;/p&gt;
&lt;h3 id=&quot;用规定的Python方法，在一行中对给定的任意整数数列，按照如下规则排序：&quot;&gt;&lt;a href=&quot;#用规定的Python方法，在一行中对给定的任意整数数列，按照如下规则排序：&quot; class=&quot;headerlink&quot; title=&quot;用规定的Python方法，在一行中对给定的任意整数数列，按照如下规则排序：&quot;&gt;&lt;/a&gt;用规定的Python方法，在一行中对给定的任意整数数列，按照如下规则排序：&lt;/h3&gt;&lt;p&gt;a) 非负数在前，负数在后；&lt;br&gt;b) 非负数部分按照从小到大排序；&lt;br&gt;c) 负数部分按从大到小排序。&lt;br&gt;如： 数列 foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]&lt;br&gt;希望排序后为[0,2,4,8,8,9,-2,-4,-4,-5,-20]&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]
&amp;gt;&amp;gt;&amp;gt; sorted(foo, key=lambda x: (x&amp;gt;=0 and -abs(1/float(x+1)) or abs(x)))
[0, 2, 4, 8, 8, 9, -2, -4, -4, -5, -20]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;给出用递归的方式求斐波那契数列的第n项的方法：&quot;&gt;&lt;a href=&quot;#给出用递归的方式求斐波那契数列的第n项的方法：&quot; class=&quot;headerlink&quot; title=&quot;给出用递归的方式求斐波那契数列的第n项的方法：&quot;&gt;&lt;/a&gt;给出用递归的方式求斐波那契数列的第n项的方法：&lt;/h3&gt;&lt;p&gt;（斐波那契数列指的是这样一个数列0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，…）&lt;br&gt;特别指出：第0项是0，第1项是第一个1。这个数列从第2项开始，每一项都等于前两项之和。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# test.py
def fib(n):
    if n &amp;lt;= 1:
        return n
    else:
        return(fib(n - 1) + fib(n - 2))
if __name__ == &amp;apos;__main__&amp;apos;:
    n = 10
    print fib(n)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;求大于正整数n的最小质数&quot;&gt;&lt;a href=&quot;#求大于正整数n的最小质数&quot; class=&quot;headerlink&quot; title=&quot;求大于正整数n的最小质数&quot;&gt;&lt;/a&gt;求大于正整数n的最小质数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;import math

def func_get_prime(n):
    return filter(lambda x: not [x % i for i in range(2, int(math.sqrt(x)) + 1) if x % i == 0], range(2, n + 1))
if __name__ == &amp;apos;__main__&amp;apos;:
    print min(func_get_prime(100))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在不声明新变量的情况下，让变量a和变量b的值互换？&quot;&gt;&lt;a href=&quot;#在不声明新变量的情况下，让变量a和变量b的值互换？&quot; class=&quot;headerlink&quot; title=&quot;在不声明新变量的情况下，让变量a和变量b的值互换？&quot;&gt;&lt;/a&gt;在不声明新变量的情况下，让变量a和变量b的值互换？&lt;/h3&gt;&lt;p&gt;解答：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 1
&amp;gt;&amp;gt;&amp;gt; b = 9
&amp;gt;&amp;gt;&amp;gt; a = a + b
&amp;gt;&amp;gt;&amp;gt; b = a - b
&amp;gt;&amp;gt;&amp;gt; a = a - b
&amp;gt;&amp;gt;&amp;gt; a
9
&amp;gt;&amp;gt;&amp;gt; b
1
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Python是如何进行内存管理的？&quot;&gt;&lt;a href=&quot;#Python是如何进行内存管理的？&quot; class=&quot;headerlink&quot; title=&quot;Python是如何进行内存管理的？&quot;&gt;&lt;/a&gt;Python是如何进行内存管理的？&lt;/h3&gt;&lt;p&gt;解答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制&lt;br&gt;&lt;strong&gt;一、对象的引用计数机制&lt;/strong&gt;&lt;br&gt;python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。&lt;br&gt;引用计数增加的情况：&lt;br&gt;1，一个对象分配一个新名称&lt;br&gt;2，将其放入一个容器中（如列表、元组或字典）&lt;br&gt;引用计数减少的情况：&lt;br&gt;1，使用del语句对对象别名显示的销毁&lt;br&gt;2，引用超出作用域或被重新赋值&lt;br&gt;sys.getrefcount( )函数可以获得对象的当前引用计数&lt;br&gt;多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。&lt;br&gt;&lt;strong&gt;二、垃圾回收&lt;/strong&gt;&lt;br&gt;1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。&lt;br&gt;2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。&lt;br&gt;&lt;strong&gt;三、内存池机制&lt;/strong&gt;&lt;br&gt;Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。&lt;br&gt;1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。&lt;br&gt;2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。&lt;br&gt;3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。&lt;/p&gt;
&lt;h3 id=&quot;什么是lambda函数？它有什么好处&quot;&gt;&lt;a href=&quot;#什么是lambda函数？它有什么好处&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda函数？它有什么好处?&quot;&gt;&lt;/a&gt;什么是lambda函数？它有什么好处?&lt;/h3&gt;&lt;p&gt;解答：&lt;/p&gt;
&lt;p&gt;lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数&lt;br&gt;lambda函数：首要用途是指短小的回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lambda [arguments]:expression
&amp;gt;&amp;gt;&amp;gt; a=lambda x,y:x+y
&amp;gt;&amp;gt;&amp;gt; a(3,11)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;现在有一个文件url-txt，每一行都是一个网站名（例如：map-baidu-com）请用Python读取这个文件并且使用正则表达式匹配简单的以“www-”，以“-com”或者”-edu”或者”-gov”作结尾的web域名，然后输出到另一个文件中&quot;&gt;&lt;a href=&quot;#现在有一个文件url-txt，每一行都是一个网站名（例如：map-baidu-com）请用Python读取这个文件并且使用正则表达式匹配简单的以“www-”，以“-com”或者”-edu”或者”-gov”作结尾的web域名，然后输出到另一个文件中&quot; class=&quot;headerlink&quot; title=&quot;现在有一个文件url.txt，每一行都是一个网站名（例如：map.baidu.com）请用Python读取这个文件并且使用正则表达式匹配简单的以“www.”，以“.com”或者”.edu”或者”.gov”作结尾的web域名，然后输出到另一个文件中&quot;&gt;&lt;/a&gt;现在有一个文件url.txt，每一行都是一个网站名（例如：map.baidu.com）请用Python读取这个文件并且使用正则表达式匹配简单的以“www.”，以“.com”或者”.edu”或者”.gov”作结尾的web域名，然后输出到另一个文件中&lt;/h3&gt;&lt;p&gt;解答：&lt;br&gt;        coding:utf-8&lt;br&gt;        import re&lt;br&gt;        sch = re.compile(r”^www.*[com,edu,gov]$”)&lt;br&gt;        listt = []&lt;br&gt;        with open(‘C:\Users\test\Desktop\test.txt’, ‘r’) as f:&lt;br&gt;            file_list = f.readlines()&lt;br&gt;            for i in file_list:&lt;br&gt;                listt.append(sch.match(i).group())&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with open(&amp;apos;C:\Users\test\Desktop\\chen.txt&amp;apos;, &amp;apos;a&amp;apos;) as f:
    for i in listt:
        f.write(i + &amp;apos;\n&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;写一个装饰器，计算这个函数运行了多长时间？&quot;&gt;&lt;a href=&quot;#写一个装饰器，计算这个函数运行了多长时间？&quot; class=&quot;headerlink&quot; title=&quot;写一个装饰器，计算这个函数运行了多长时间？&quot;&gt;&lt;/a&gt;写一个装饰器，计算这个函数运行了多长时间？&lt;/h3&gt;&lt;p&gt;1.复杂&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import time
from functools import wraps
import random


def fn_timer(function):
    @wraps(function)
    def function_timer(*args, **kwargs):
        t0 = time.time()
        result = function(*args, **kwargs)
        t1 = time.time()
        print (&amp;quot;Total time running %s: %s seconds&amp;quot; %(function.func_name, str(t1-t0)))
        return result
    return function_timer


@fn_timer
def random_sort(n):
    return sorted([random.random() for i in range(n)])


if __name__ == &amp;quot;__main__&amp;quot;:
    random_sort(2000000)
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# coding:utf8
import time

# clock()方法返回当前的处理器时间，以秒表示Unix上一个浮点数。
# 精度取决于具有相同名称的C函数，但在任何情况下，
# 这是使用于基准Python或定时的算法函数。

def suan(fn):
    def wrapper():
        start = time.clock()
        print start
        fn()
        end = time.clock()
        print end
        return end - start
    return wrapper
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@suan
def func():
    return range(100000)

print func()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;django查询取出数据库”User表”中字段”name”为”chen”和”ning”的数据？&quot;&gt;&lt;a href=&quot;#django查询取出数据库”User表”中字段”name”为”chen”和”ning”的数据？&quot; class=&quot;headerlink&quot; title=&quot;django查询取出数据库”User表”中字段”name”为”chen”和”ning”的数据？&quot;&gt;&lt;/a&gt;django查询取出数据库”User表”中字段”name”为”chen”和”ning”的数据？&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# django查询方法
query = Author.objects.filter(first_name__in=[&amp;quot;chen&amp;quot;, &amp;quot;ning&amp;quot;])

# Q查询
query = Author.objects.filter(Q(first_name__contains=&amp;quot;chen&amp;quot;) | Q(first_name__contains=&amp;quot;ning&amp;quot;))
query = Author.objects.filter(Q(first_name=&amp;quot;chen&amp;quot;) | Q(first_name=&amp;quot;ning&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/293387-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;小癖好~爱做面试题，感觉每次
    
    </summary>
    
      <category term="python" scheme="http://python-ning.github.io/categories/python/"/>
    
    
      <category term="面试题" scheme="http://python-ning.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>mac安装mysql</title>
    <link href="http://python-ning.github.io/2016/05/14/mysql_mac_install_question/"/>
    <id>http://python-ning.github.io/2016/05/14/mysql_mac_install_question/</id>
    <published>2016-05-14T07:00:00.000Z</published>
    <updated>2016-06-27T22:43:49.000Z</updated>
    
    <content type="html">&lt;p&gt;mac下安装mysql，遇到了一个小波折，折磨了我一天，解决了，也借此机会总结一下。&lt;/p&gt;
&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;注意&lt;/code&gt; mac上一定要安装xcode，哪怕你不是ios开发工程师也是要安装的，因为在苹果上开发大多数操作都要依赖xcode&lt;/p&gt;
&lt;p&gt;mysql 在mac上安装有两种方式：&lt;/p&gt;
&lt;h3 id=&quot;1-Homebrew安装mysql&quot;&gt;&lt;a href=&quot;#1-Homebrew安装mysql&quot; class=&quot;headerlink&quot; title=&quot;1.Homebrew安装mysql&quot;&gt;&lt;/a&gt;1.Homebrew安装mysql&lt;/h3&gt;&lt;p&gt;Homebrew类似ubuntu系统的apt-get包管理，命令也基本一样。&lt;/p&gt;
&lt;h2 id=&quot;安装Homebrew&quot;&gt;&lt;a href=&quot;#安装Homebrew&quot; class=&quot;headerlink&quot; title=&quot;安装Homebrew&quot;&gt;&lt;/a&gt;安装Homebrew&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Homebrew基本命令&quot;&gt;&lt;a href=&quot;#Homebrew基本命令&quot; class=&quot;headerlink&quot; title=&quot;Homebrew基本命令&quot;&gt;&lt;/a&gt;Homebrew基本命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ brew
Example usage:
 brew [info | home | options ] [FORMULA...]
 brew install FORMULA...   // 安装包
 brew uninstall FORMULA... // 卸载包
 brew search [foo]         // 搜索包
 brew list [FORMULA...]    // 显示已经安装的软件列表
 brew update               // 更新brew
 brew upgrade [FORMULA...] // 更新包，不跟包名就是更新所有包
 brew pin/unpin [FORMULA...]
Troubleshooting:
 brew doctor
 brew install -vd FORMULA
 brew [--env | --config]
Brewing:
 brew create [URL [--no-fetch]]
 brew edit [FORMULA...]
 open https://github.com/Homebrew/homebrew/wiki/Formula-Cookbook
Further help:
 man brew
 brew home
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装mysql&quot;&gt;&lt;a href=&quot;#安装mysql&quot; class=&quot;headerlink&quot; title=&quot;安装mysql&quot;&gt;&lt;/a&gt;安装mysql&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;sudo brew install mysql
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;mysql启动，重启，关闭服务&quot;&gt;&lt;a href=&quot;#mysql启动，重启，关闭服务&quot; class=&quot;headerlink&quot; title=&quot;mysql启动，重启，关闭服务&quot;&gt;&lt;/a&gt;mysql启动，重启，关闭服务&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;sudo brew services start mysql
sudo brew services restart mysql
sudo brew services stop mysql
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;常遇问题1&quot;&gt;&lt;a href=&quot;#常遇问题1&quot; class=&quot;headerlink&quot; title=&quot;常遇问题1&quot;&gt;&lt;/a&gt;常遇问题1&lt;/h2&gt;&lt;p&gt;当mysql安装好，启动了服务后，我们&lt;code style=&quot;color: red&quot;&gt;mysql -u root -p&lt;/code&gt;(mysql默认密码为空)时，可能会出现以下报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error: Can&amp;apos;t connect to local MySQL server through socket &amp;apos;/tmp/mysql.sock&amp;apos; (111)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;解决办法1&quot;&gt;&lt;a href=&quot;#解决办法1&quot; class=&quot;headerlink&quot; title=&quot;解决办法1&quot;&gt;&lt;/a&gt;解决办法1&lt;/h2&gt;&lt;p&gt;1.查找电脑上所有的mysql都在哪里&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo find / -name mysql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.找出mysql安装的目录，给权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chown -R mysql:mysql xxx你的mysql目录xxx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实在不知道，你就把所有搜出来的mysql目录文件都给权限，前提是你自己的测试开发环境，可别在服务器上这么搞。&lt;/p&gt;
&lt;h3 id=&quot;2-dmg包双击安装&quot;&gt;&lt;a href=&quot;#2-dmg包双击安装&quot; class=&quot;headerlink&quot; title=&quot;2.dmg包双击安装&quot;&gt;&lt;/a&gt;2.dmg包双击安装&lt;/h3&gt;&lt;p&gt;在mysql官网选downloads，选Community（社区版的意思），点这个&lt;code style=&quot;color: red&quot;&gt;MySQL Community Server (GPL)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载那个dmg后缀名的包下载下来点点点，下一步就好了，安装好以后他会给你个初始登陆密码记录下来，然后他会在你的设置里多一个mysql的图标，点击进入后可以开启关闭mysql服务&lt;/p&gt;
&lt;p&gt;基本就安装好了，也可能会有1遇到的问题，按上述方法改就好了。&lt;/p&gt;
&lt;p&gt;ps：贴图太麻烦，还有好多事要做，我要速度学成为大牛。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;mac下安装mysql，遇到了一个小波折，折磨了我一天，解决了，也借此机会总结一下。&lt;/p&gt;
&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;注意&lt;/code&gt; mac上一定要安装xcode，哪怕你不是ios开发工程师也是要安装的，因为在苹果上开发大多数操作都要依赖
    
    </summary>
    
      <category term="mysql" scheme="http://python-ning.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://python-ning.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>读改善python程序的91个建议总结</title>
    <link href="http://python-ning.github.io/2016/04/18/reading_comprehension_python_1/"/>
    <id>http://python-ning.github.io/2016/04/18/reading_comprehension_python_1/</id>
    <published>2016-04-18T07:00:00.000Z</published>
    <updated>2016-06-27T23:04:51.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;建议一-字符串格式化，让可读性高一些&quot;&gt;&lt;a href=&quot;#建议一-字符串格式化，让可读性高一些&quot; class=&quot;headerlink&quot; title=&quot;建议一 字符串格式化，让可读性高一些&quot;&gt;&lt;/a&gt;建议一 字符串格式化，让可读性高一些&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;print &amp;apos;Hello %S&amp;apos; %(&amp;apos;Chen&amp;apos;,)
==&amp;gt; print &amp;apos;Hello %(name)s!&amp;apos; %{&amp;apos;name&amp;apos;: &amp;apos;Chen&amp;apos;}


value = {&amp;apos;greet&amp;apos;: &amp;apos;Hello world&amp;apos;, &amp;apos;language&amp;apos;: &amp;apos;Python&amp;apos;}
print &amp;apos;%(greet)s from %(language)s.&amp;apos; % value
==&amp;gt;  print &amp;apos;{greet} from {language}&amp;apos;.format(greet = &amp;apos;Hello world&amp;apos;, language = Python&amp;apos;&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议二-命名规则&quot;&gt;&lt;a href=&quot;#建议二-命名规则&quot; class=&quot;headerlink&quot; title=&quot;建议二 命名规则&quot;&gt;&lt;/a&gt;建议二 命名规则&lt;/h3&gt;&lt;p&gt;1.避免只用大小写来区分不同的对象&lt;br&gt;2.避免使用容易引起混淆的名称比如（0o混淆，l1混淆）&lt;br&gt;3.不要害怕过长的变量名。&lt;/p&gt;
&lt;p&gt;安装pep8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install -U pep8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检测代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pep8 --first optparse.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示详细不符合pep8的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pep8 --show-source --show-pep8 test.py
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议六-编写函数的4个原则&quot;&gt;&lt;a href=&quot;#建议六-编写函数的4个原则&quot; class=&quot;headerlink&quot; title=&quot;建议六 编写函数的4个原则&quot;&gt;&lt;/a&gt;建议六 编写函数的4个原则&lt;/h3&gt;&lt;p&gt;1.函数设计要尽量短小，嵌套层次不宜过深，if elif while for 等循环判断的，最好能控制在3层以内。&lt;br&gt;2.函数声明应该做到合理、简单、易于使用，参数个数不宜过多，。&lt;br&gt;3.函数参数设计应该考虑向下兼容，比如一个函数，多加了一个参数，来记录功能的日志，要加一个默认参数，便于兼容。&lt;br&gt;4.一个函数只干一件事，尽量保证函数语句粒度的一致性，&lt;br&gt;python中函数设计的好习惯好包括：不要再函数中定义可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等。&lt;/p&gt;
&lt;h3 id=&quot;建议七-将常量集中到一个文件&quot;&gt;&lt;a href=&quot;#建议七-将常量集中到一个文件&quot; class=&quot;headerlink&quot; title=&quot;建议七 将常量集中到一个文件&quot;&gt;&lt;/a&gt;建议七 将常量集中到一个文件&lt;/h3&gt;&lt;p&gt;通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下划线连接各个单词，如MAX_OVERFLOW. 然而这种方式并没有实现真正的常量，其对应的值仍然可以改变，这只是一种约定俗成的风格。&lt;/p&gt;
&lt;p&gt;通过自定义的类实现常量功能。这要求符合”命名全部为大写”和”值一旦绑定便不可再修改”这两个条件。下面是一种较为常见的解决方法，他通过对常量对应的值进行修改时或者命名不符合规范时抛出异常来满足以上变量的两个条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class _const:
    class ConstError(TypeError): pass
    class ConstCaseerror(ConstError): pass

    def __setattr__(self,name, value):
        if self.__dict__.has_key(name):
            raise self.ConstError, &amp;quot;Can&amp;apos;t change const.%s&amp;quot; % name
        if not name.isupper():
            raise self.ConstError, &amp;quot;const name &amp;apos;%s&amp;apos; is not all uppercase&amp;quot; % name
        self.__dict__[name] = value
import sys
sys.modules[__name__] = _const()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果上面的代码对应的模块名为const，使用的时候只需要import const,便可以直接定义常量了， 如以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import const
const.COMPANY = &amp;quot;IBM&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;利用assert语句来发现问题&quot;&gt;&lt;a href=&quot;#利用assert语句来发现问题&quot; class=&quot;headerlink&quot; title=&quot;利用assert语句来发现问题&quot;&gt;&lt;/a&gt;利用assert语句来发现问题&lt;/h3&gt;&lt;p&gt;断言在很多语言中都存在，在python中的语法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert expression1 [&amp;quot;,&amp;quot; expression2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中计算expression1的值会返回True或者False， 当值为False的时候会引发AssertionError，而expression2是可选的，常用来传递具体的异常信息。&lt;/p&gt;
&lt;p&gt;python -O test.py 便可以禁用断言&lt;/p&gt;
&lt;p&gt;1.不要滥用，这是使用断言最基本的原则。&lt;br&gt;2.如果python本身的异常能够处理就不要再使用断言。&lt;br&gt;3.不要使用断言来检查用户的输入&lt;br&gt;4.在函数调用后，当需要确认返回值是否合理时可以使用断言&lt;br&gt;5.当条件是业务逻辑继续下去的先决条件时可以使用断言&lt;/p&gt;
&lt;h3 id=&quot;建议九-数据交换值的时候不推荐使用中间变量&quot;&gt;&lt;a href=&quot;#建议九-数据交换值的时候不推荐使用中间变量&quot; class=&quot;headerlink&quot; title=&quot;建议九 数据交换值的时候不推荐使用中间变量&quot;&gt;&lt;/a&gt;建议九 数据交换值的时候不推荐使用中间变量&lt;/h3&gt;&lt;p&gt;   c = a&lt;br&gt;   a = b&lt;br&gt;   b = c&lt;/p&gt;
&lt;p&gt;   ==&amp;gt; a,b = b,a&lt;/p&gt;
&lt;p&gt;运行两者效率不一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In [1]: from timeit import Timer

In [2]: Timer(&amp;apos;c = x;x=y;y=c&amp;apos;,&amp;apos;x = 2; y=3&amp;apos;)
Out[2]: &amp;lt;timeit.Timer instance at 0x7f58a8273830&amp;gt;

In [3]: Timer(&amp;apos;c = x;x=y;y=c&amp;apos;,&amp;apos;x = 2; y=3&amp;apos;).timeit()
Out[3]: 0.03874492645263672

In [4]: Timer(&amp;apos;x,y = y,x&amp;apos;, &amp;apos;x=2;y=3&amp;apos;).timeit()
Out[4]: 0.03464508056640625

In [5]:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议十-充分利用-Lazy-evaluation的特性&quot;&gt;&lt;a href=&quot;#建议十-充分利用-Lazy-evaluation的特性&quot; class=&quot;headerlink&quot; title=&quot;建议十 充分利用 Lazy evaluation的特性&quot;&gt;&lt;/a&gt;建议十 充分利用 Lazy evaluation的特性&lt;/h3&gt;&lt;p&gt;1.避免不必要的计算，带来性能上的提升，比如 if x and y ,在x为false的情况下y表达式的值不再计算，二对于if x or y, 当x的值为true的时候将直接返回,不再计算y的值。所以当我们循环一个比较大的数据，先从可能性比较高的一方去循环他，从而节省了时间，提高了效率&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;节省空间，使得无限循环的数据结构成为可能。python中最典型的使用延迟计算的例子就是生成器表达式了，它仅在每次需要计算的时候通过yield产生所需要的元素。&lt;/p&gt;
&lt;p&gt; def fib():&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a, b = 0, 1
while True:
    yield a
    a, b = b, a + b
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;from itertools import islice&lt;br&gt;print list(islice(fib(), 5))&lt;br&gt; [0, 1, 1, 2, 3]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;建议12-不推荐使用type&quot;&gt;&lt;a href=&quot;#建议12-不推荐使用type&quot; class=&quot;headerlink&quot; title=&quot;建议12 不推荐使用type()&quot;&gt;&lt;/a&gt;建议12 不推荐使用type()&lt;/h3&gt;&lt;p&gt;基于内建类型扩展的用户自定义类型，type()函数并不能准确返回结果。&lt;br&gt;这时候用 isinstance(object, classinfo)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isinstance(2, int)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议13-当涉及触发运算的时候尽量先将操作数转换为浮点类型再做运算&quot;&gt;&lt;a href=&quot;#建议13-当涉及触发运算的时候尽量先将操作数转换为浮点类型再做运算&quot; class=&quot;headerlink&quot; title=&quot;建议13 当涉及触发运算的时候尽量先将操作数转换为浮点类型再做运算&quot;&gt;&lt;/a&gt;建议13 当涉及触发运算的时候尽量先将操作数转换为浮点类型再做运算&lt;/h3&gt;&lt;h3 id=&quot;建议14-eval-不安全&quot;&gt;&lt;a href=&quot;#建议14-eval-不安全&quot; class=&quot;headerlink&quot; title=&quot;建议14 eval()不安全&quot;&gt;&lt;/a&gt;建议14 eval()不安全&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;__import__(&amp;quot;os&amp;quot;).system(&amp;quot;dir&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你的当前目录下的所有文件都出来了&lt;/p&gt;
&lt;h3 id=&quot;建议15-is-和-“-”&quot;&gt;&lt;a href=&quot;#建议15-is-和-“-”&quot; class=&quot;headerlink&quot; title=&quot;建议15 is 和 “==”&quot;&gt;&lt;/a&gt;建议15 is 和 “==”&lt;/h3&gt;&lt;p&gt;is的作用是用来检查对象的标识符是否一致的，也就是比较两个对象在内存中是否拥有同一块内存空间，它并不适合用来判断两个字符串是否相等；而”==”才是用来检验两个对象的值是否相等的，它实际调用内部&lt;strong&gt;eq&lt;/strong&gt;()方法。&lt;/p&gt;
&lt;h3 id=&quot;建议17-考虑兼容性，尽可能使用Unicode&quot;&gt;&lt;a href=&quot;#建议17-考虑兼容性，尽可能使用Unicode&quot; class=&quot;headerlink&quot; title=&quot;建议17 考虑兼容性，尽可能使用Unicode&quot;&gt;&lt;/a&gt;建议17 考虑兼容性，尽可能使用Unicode&lt;/h3&gt;&lt;p&gt;Python内建的字符串有两种类型：str和Unicode，它们拥有共同的祖先basestring。其中Unicode是Python2.0中引入的一种新的数据类型，所有的Unicode字符串都是Unicode类型的实例。创建一个Unicode字符相对简单。&lt;/p&gt;
&lt;p&gt;因此要解决乱码问题可以使用Unicode作为中间介质来完成转换。首先需要对读入的字符用UTF-8进行解码，然后再用GBK进行编码。修改后的结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filehandle = open(&amp;quot;test.txt&amp;quot;,&amp;apos;r&amp;apos;)
print (filehandle.read().decode(&amp;quot;utf-8&amp;quot;)).encode(&amp;quot;gbk&amp;quot;)
filehandle.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于BOM：&lt;br&gt;Unicode存储有字节序的问题，例如“汉”字的Unicode编码是0X6C49，如果将6C写在前面，则为big endian，将49写在前面则成为little endian。UTF-16以两个字节为编码单元，在字符的传送过程中，为了标明字节的顺序，Unicode规范中推荐使用BOM（Byte Order Mark）：即在 UCS编码中用一个叫做ZERO WIDTH NO-BREAK SPACE的字符，它的编码是FEFF（该编码在UCS中不存在对应的字符），UCS规范建议在传输字节流前，先传输字符ZERO WIDTH NO-BREAK SPACE。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。 UTF-8使用字节来编码，一般不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符ZERO WIDTH NO-BREAK SPACE的UTF-8编码是EF BB BF。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。&lt;/p&gt;
&lt;p&gt;示例二分析：Python中默认的编码是ASCII编码（这点可以通过sys.getdefaultencoding()来验证），所以unicodetest.py文件是以ASCII形式保存的，s是包含中文字符的普通字符串。当调用print方法输出的时候会隐式地进行从ASCII到系统默认编码（Windows上为CP936）的转换，中文字符并不是ASCII字符，而此时源文件中又未指定其他编码方式，Python解释器并不知道如何正确处理这种情况，便会抛出异常：SyntaxError: Non-ASCII character ‘\xd6’ in file unicodetest.py on line 1。因此，要避免这种错误需要在源文件中进行编码声明，声明可用正则表达式&lt;br&gt;“coding[:=]\s*([-\w.]+)”表示。一般来说进行源文件编码声明有以下3种方式：&lt;/p&gt;
&lt;p&gt;第一种声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# coding=&amp;lt;encoding name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二种声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: &amp;lt;encoding name&amp;gt; -*-
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第三种声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# vim: set fileencoding=&amp;lt;encoding name&amp;gt; :
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议18：构建合理的包层次来管理module&quot;&gt;&lt;a href=&quot;#建议18：构建合理的包层次来管理module&quot; class=&quot;headerlink&quot; title=&quot;建议18：构建合理的包层次来管理module&quot;&gt;&lt;/a&gt;建议18：构建合理的包层次来管理module&lt;/h3&gt;&lt;p&gt;什么是包呢？简单说包即是目录，但与普通目录不同，它除了包含常规的Python文件（也就是模块）以外，还包含一个&lt;strong&gt;init&lt;/strong&gt;.py文件，同时它允许嵌套。包结构如下：&lt;br&gt;        Package/ &lt;strong&gt;init&lt;/strong&gt;.py&lt;br&gt;        Module1.py&lt;br&gt;        Module2.py&lt;br&gt;        Subpackage/ &lt;strong&gt;init&lt;/strong&gt;.py&lt;br&gt;        Module1.py&lt;br&gt;        Module2.py&lt;/p&gt;
&lt;p&gt;以下是一个可供参考的Python项目结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ProjectName/
|---README
|----LICENSE
|----setup.py
|-----requirements.txt
|------sample/
|    |----__init__.py
|    |----core.py
|    |----helpers.py
|------docs/
|    |------conf.py
|    |------index.rst
|------bin/
|------package/
|    |-----__init__.py
|    |-----subpackage/
|    |------........
|------tests/
|    |------test_basic.py
|    |------test_advanced.py
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议19：有节制地使用from…import语句&quot;&gt;&lt;a href=&quot;#建议19：有节制地使用from…import语句&quot; class=&quot;headerlink&quot; title=&quot;建议19：有节制地使用from…import语句&quot;&gt;&lt;/a&gt;建议19：有节制地使用from…import语句&lt;/h3&gt;&lt;p&gt;在使用import的时候注意以下几点：&lt;br&gt;·一般情况下尽量优先使用import a形式，如访问B时需要使用a.B的形式。&lt;br&gt;·有节制地使用from a import B形式，可以直接访问B。&lt;br&gt;·尽量避免使用from a import *，因为这会污染命名空间，并且无法清晰地表示导入了哪些对象&lt;/p&gt;
&lt;p&gt;为什么在使用import的时候要注意以上几点呢？在回答这个问题之前先来简单了解一下Python的import机制。Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块相关的信息被存放在sys.modules中。读者导入sys模块后在Python解释器中输入sys.modules.items()便可显示所有预加载模块的相关信息。当加载一个模块的时候，解释器实际上要完成以下动作：&lt;br&gt;1）在sys.modules中进行搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。&lt;br&gt;2）如果在sys.modules中找不到对应模块的名称，则为需要导入的模块创建一个字典对象，并将该对象信息插入sys.modules中。&lt;br&gt;3）加载前确认是否需要对模块对应的文件进行编译，如果需要则先进行编译。&lt;br&gt;4）执行动态加载，在当前模块的命名空间中执行编译后的字节码，并将其中所有的对象放入模块对应的字典中。&lt;/p&gt;
&lt;h3 id=&quot;建议20：优先使用absolute-import来导入模块&quot;&gt;&lt;a href=&quot;#建议20：优先使用absolute-import来导入模块&quot; class=&quot;headerlink&quot; title=&quot;建议20：优先使用absolute import来导入模块&quot;&gt;&lt;/a&gt;建议20：优先使用absolute import来导入模块&lt;/h3&gt;&lt;p&gt;假设有如下文件结构，其中app/sub1/string.py中定义了一个lower()方法，那么当在mod1.py中import string之后再使用string.lower()方法时，到底引用的是sub1/string.py中的lower()方法，还是Python标准库中string里面的lower()方法呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app/
__init__.py
sub1/
__init__.py
mod1.py
string.py
sub2/
__init__.py
mod2.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从程序的输出会发现，它引用的是app/sub1/string.py中的lower()方法。显然解释器默认先从当前目录下搜索对应的模块，当搜到string.py的时候便停止搜索进行动态加载。那么，如果要使用Python自带的string模块中的方法，该怎么实现呢？这就涉及absolute import和relative import相关的话题了。&lt;br&gt;在Python2.4以前默认为隐式的relative import，局部范围的模块将覆盖同名的全局范围的模块。如果要使用标注库中同名的模块，你不得不去深入考察sys.modules一番，显然这并不是一种非常友好的做法。Python2.5中后虽然默认的仍然是relative import，但它为absolute import提供了一种新的机制，在模块中使用from &lt;strong&gt;future&lt;/strong&gt; import absolute_import 语句进行说明后再进行导入。同时它还通过点号提供了一种显式进行relative import的方法，“.”表示当前目录，“..”表示当前目录的上一层目录。例如想在mod1.py中导入string.py，可以使用from . import string，其中mod1所在的包层次结构为app.sub1.mod1，“.”表示app.sub1；如果想导入sub2/mo2.py可以使用from ..sub2 import mod2，“..”代表的是app。&lt;br&gt;但事情是不是就此结束了呢？远不止，使用显式relative import之后再运行程序一不小心你就有可能遇到这种错误“ValueError: Attempted relative import in non-package”。这是什么原因呢？这个问题产生的原因在于relative import使用模块的&lt;strong&gt;name&lt;/strong&gt;属性来决定当前模块在包层次结构中的位置，如果当前的模块名称中不包含任何包的信息，那么它将默认为模块在包的顶层位置，而不管模块在文件系统中的实际位置。而在relative import的情形下，&lt;strong&gt;name&lt;/strong&gt;会随着文件加载方式的不同而发生改变，上例中如在目录app/sub1/下运行Python mod1.py，会发现模块的&lt;strong&gt;name&lt;/strong&gt;为&lt;strong&gt;main&lt;/strong&gt;，但如果在目录app/sub1/下运行Python-m mod1.py，会发现&lt;strong&gt;name&lt;/strong&gt;变为mod1。其中-m的作用是使得一个模块像脚本一样运行。而无论以何种方式加载，当在包的内部运行脚本的时候，包相关的结构信息都会丢失，默认当前脚本所在的位置为模块在包中的顶层位置，因此便会抛出异常。如果确实需要将模块当作脚本一样运行，解决方法之一是在包的顶层目录中加入参数-m运行该脚本，上例中如果要运行脚本mod1.py可以在app所在的目录的位置输入Python -m app.sub1.mod1。另一个解决这个问题的方法是利用Python2.6在模块中引入的&lt;strong&gt;package&lt;/strong&gt;属性，设置&lt;strong&gt;package&lt;/strong&gt;之后，解释器会根据&lt;strong&gt;package&lt;/strong&gt;和&lt;strong&gt;name&lt;/strong&gt;的值来确定包的层次结构。上面的例子中如果将mod1.py修改为以下形式便不会出现在包结构内运行模块对应的脚本时出错的情况了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot; and __package__ is None:
import sys
import os.path
sys.path[0] = os.path.abspath(&amp;quot;./../../&amp;quot;)
print sys.path[0]
import app.sub1
__package__ =  str(&amp;apos;app.sub1&amp;apos;)
from . import string
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议26：-深入理解None，正确判断对象是否为空&quot;&gt;&lt;a href=&quot;#建议26：-深入理解None，正确判断对象是否为空&quot; class=&quot;headerlink&quot; title=&quot;建议26： 深入理解None，正确判断对象是否为空&quot;&gt;&lt;/a&gt;建议26： 深入理解None，正确判断对象是否为空&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;if xxx is not None:
    Do something
else：
    Not do something
    上边会走到else
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只有None == None是True， 其他像0，[], (),’’等都是False&lt;/p&gt;
&lt;p&gt;大多是情况下用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(XXX):
    do or not do
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议27-连接字符串用join比”-”好&quot;&gt;&lt;a href=&quot;#建议27-连接字符串用join比”-”好&quot; class=&quot;headerlink&quot; title=&quot;建议27 连接字符串用join比”+”好&quot;&gt;&lt;/a&gt;建议27 连接字符串用join比”+”好&lt;/h3&gt;&lt;p&gt;效率要高&lt;/p&gt;
&lt;h3 id=&quot;建议28-format&quot;&gt;&lt;a href=&quot;#建议28-format&quot; class=&quot;headerlink&quot; title=&quot;建议28 .format&quot;&gt;&lt;/a&gt;建议28 .format&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;In [15]: &amp;apos;adasd asd as asd  {0} id {1}&amp;apos;.format(&amp;apos;ning&amp;apos;,&amp;apos;chen&amp;apos;)
Out[15]: &amp;apos;adasd asd as asd  ning id chen&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议31-重点-记住函数传参既不是传值也不是传引用&quot;&gt;&lt;a href=&quot;#建议31-重点-记住函数传参既不是传值也不是传引用&quot; class=&quot;headerlink&quot; title=&quot;建议31 重点 记住函数传参既不是传值也不是传引用&quot;&gt;&lt;/a&gt;建议31 重点 记住函数传参既不是传值也不是传引用&lt;/h3&gt;&lt;p&gt;python中的函数参数既不是传值也不是传引用，也不是可变对象传引用，不可变对象传值，正确的叫法应该是传对象(call by object)或者说传对象的引用(call-by-object-reference)。函数参数在传递的过程中将整个对象传入，对可变对象的修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象，二对于不可变对象，由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后复制来实现。&lt;/p&gt;
&lt;h3 id=&quot;建议36-掌握字符串的基本用法&quot;&gt;&lt;a href=&quot;#建议36-掌握字符串的基本用法&quot; class=&quot;headerlink&quot; title=&quot;建议36 掌握字符串的基本用法&quot;&gt;&lt;/a&gt;建议36 掌握字符串的基本用法&lt;/h3&gt;&lt;p&gt;basestring 包括str 和 unicode&lt;/p&gt;
&lt;p&gt;字符串方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isalnum()
isalpha()
isdigit()
islower()
isupper()
isspace()
istitle()
startswith()
endwith()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;建议14-eval-不安全-1&quot;&gt;&lt;a href=&quot;#建议14-eval-不安全-1&quot; class=&quot;headerlink&quot; title=&quot;建议14 eval()不安全&quot;&gt;&lt;/a&gt;建议14 eval()不安全&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;建议一-字符串格式化，让可读性高一些&quot;&gt;&lt;a href=&quot;#建议一-字符串格式化，让可读性高一些&quot; class=&quot;headerlink&quot; title=&quot;建议一 字符串格式化，让可读性高一些&quot;&gt;&lt;/a&gt;建议一 字符串格式化，让可读性高一些&lt;/h3&gt;&lt;pre&gt;&lt;cod
    
    </summary>
    
      <category term="python" scheme="http://python-ning.github.io/categories/python/"/>
    
    
      <category term="总结" scheme="http://python-ning.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>django(八)五步教你实现使用Nginx+uWSGI+Django方法部署Django程序(上)</title>
    <link href="http://python-ning.github.io/2016/04/14/python_django_uwsgi/"/>
    <id>http://python-ning.github.io/2016/04/14/python_django_uwsgi/</id>
    <published>2016-04-14T07:00:00.000Z</published>
    <updated>2016-04-14T17:49:14.000Z</updated>
    
    <content type="html">&lt;p&gt;Django的部署可以有很多方式，采用nginx+uwsgi的方式是其中比较常见的一种方式。&lt;/p&gt;
&lt;p&gt;在这种方式中，我们的通常做法是，将nginx作为服务器最前端，它将接收WEB的所有请求，统一管理请求。nginx把所有静态请求自己来处理（这是NGINX的强项）。然后，NGINX将所有非静态请求通过uwsgi传递给Django，由Django来进行处理，从而完成一次WEB请求。&lt;/p&gt;
&lt;p&gt;可见，uwsgi的作用就类似一个桥接器。起到桥梁的作用。不使用nginx，只使用uwsgi+django也是可以实现WEB服务的。uwsgi也可以直接处理WEB请求。&lt;/p&gt;
&lt;p&gt;为了完成上述的方式部署，我将分成两篇文章来分别进行阐述。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一步先解决uwsgi与django的桥接。解决在没有nginx的情况下，如何使用uwsgi+DJANGO来实现一个简单的WEB服务器。

第二步解决uwsgi与Nginx的桥接。通过nginx与uwsgi的桥接，打通nginx与django的连通，从而比较完美的实现django的部署。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文将分成五步来详细阐述uwsgi+django的部署方式。nginx+uwsgi+django的部署将在下一篇 文章中阐述。&lt;/p&gt;
&lt;p&gt;环境介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ubuntu 12.04.1 LTS
django 1.4.2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;安装uwsgi&quot;&gt;&lt;a href=&quot;#安装uwsgi&quot; class=&quot;headerlink&quot; title=&quot;安装uwsgi&quot;&gt;&lt;/a&gt;安装uwsgi&lt;/h3&gt;&lt;p&gt;1.安装pip&lt;/p&gt;
&lt;p&gt;可以参考这篇文章：&lt;a href=&quot;http://www.jsxubar.info/install-pip.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jsxubar.info/install-pip.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.安装uwsgi&lt;/p&gt;
&lt;p&gt;$ export LDFLAGS=”-Xlinker –no-as-needed”&lt;br&gt;$ pip install uwsgi&lt;/p&gt;
&lt;h3 id=&quot;测试uwsgi&quot;&gt;&lt;a href=&quot;#测试uwsgi&quot; class=&quot;headerlink&quot; title=&quot;测试uwsgi&quot;&gt;&lt;/a&gt;测试uwsgi&lt;/h3&gt;&lt;p&gt;在你的机器上写一个test.py&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# test.py
def application(env, start_response):
    start_response(&amp;apos;200 OK&amp;apos;, [(&amp;apos;Content-Type&amp;apos;,&amp;apos;text/html&amp;apos;)])
    return &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后执行shell命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uwsgi --http :8001 --wsgi-file test.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问网页：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://127.0.0.1:8001/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看在网页上是否有Hello World&lt;/p&gt;
&lt;h3 id=&quot;配置django&quot;&gt;&lt;a href=&quot;#配置django&quot; class=&quot;headerlink&quot; title=&quot;配置django&quot;&gt;&lt;/a&gt;配置django&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NOTE：
请保证你的django项目是正常使用的。可以使用
python manage.py runserver 0.0.0.0:8002
来测试一下你的django项目是否能正常跑起来。
请保证你的django程序已经关闭。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编写django_wsgi.py文件，将其放在与文件manage.py同一个目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意： 编写文件时需要注意语句os.environ.setdefault。比如，如果你的项目为mysite，则你的语句应该是 os.environ.setdefault(&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;, &amp;quot;mysite.settings&amp;quot;)

    #!/usr/bin/env python
    # coding: utf-8

    import os
    import sys

    # 将系统的编码设置为UTF8

    reload(sys)
    sys.setdefaultencoding(&amp;apos;utf8&amp;apos;)

    os.environ.setdefault(&amp;quot;DJANGO_SETTINGS_MODULE&amp;quot;, &amp;quot;mysite.settings&amp;quot;)

    from django.core.handlers.wsgi import WSGIHandler
    application = WSGIHandler()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连接django和uwsgi，实现简单的WEB服务器。&lt;/p&gt;
&lt;p&gt;我们假设你的Django项目的地址是/root/home/www/django_blog，&lt;/p&gt;
&lt;p&gt;然后，就可以执行以下命令：&lt;/p&gt;
&lt;p&gt;uwsgi –http :8000 –chdir /root/home/www/django_blog –module django_wsgi&lt;/p&gt;
&lt;p&gt;这样，你就可以在浏览器中访问你的Django程序了。所有的请求都是经过uwsgi传递给Django程序的。&lt;/p&gt;
&lt;p&gt;转载于&lt;a href=&quot;http://www.django-china.cn/topic/101/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;django中国社区&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Django的部署可以有很多方式，采用nginx+uwsgi的方式是其中比较常见的一种方式。&lt;/p&gt;
&lt;p&gt;在这种方式中，我们的通常做法是，将nginx作为服务器最前端，它将接收WEB的所有请求，统一管理请求。nginx把所有静态请求自己来处理（这是NGINX的强项）。然后
    
    </summary>
    
      <category term="python" scheme="http://python-ning.github.io/categories/python/"/>
    
    
      <category term="django" scheme="http://python-ning.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>https工作原理</title>
    <link href="http://python-ning.github.io/2016/04/13/good_article_collect_https/"/>
    <id>http://python-ning.github.io/2016/04/13/good_article_collect_https/</id>
    <published>2016-04-13T07:00:00.000Z</published>
    <updated>2016-04-13T18:43:12.000Z</updated>
    
    <content type="html">&lt;p&gt;HTTPS其实是有两部分组成：HTTP + SSL/TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/https.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户端发起HTTPS请求&quot;&gt;&lt;a href=&quot;#客户端发起HTTPS请求&quot; class=&quot;headerlink&quot; title=&quot;客户端发起HTTPS请求&quot;&gt;&lt;/a&gt;客户端发起HTTPS请求&lt;/h3&gt;&lt;p&gt;这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。&lt;/p&gt;
&lt;h3 id=&quot;服务端的配置&quot;&gt;&lt;a href=&quot;#服务端的配置&quot; class=&quot;headerlink&quot; title=&quot;服务端的配置&quot;&gt;&lt;/a&gt;服务端的配置&lt;/h3&gt;&lt;p&gt;采用HTTPS协议的服务器必须要有一套数字证书，如果没有请联系易维信客服购买全球信任的SSL证书，而使用受信任的CA签发的证书则不会弹出提示页面(GeoTrust,Symantec都是知名的CA机构)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。&lt;/p&gt;
&lt;h3 id=&quot;传送证书&quot;&gt;&lt;a href=&quot;#传送证书&quot; class=&quot;headerlink&quot; title=&quot;传送证书&quot;&gt;&lt;/a&gt;传送证书&lt;/h3&gt;&lt;p&gt;这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。&lt;/p&gt;
&lt;h3 id=&quot;客户端解析证书&quot;&gt;&lt;a href=&quot;#客户端解析证书&quot; class=&quot;headerlink&quot; title=&quot;客户端解析证书&quot;&gt;&lt;/a&gt;客户端解析证书&lt;/h3&gt;&lt;p&gt;这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。&lt;/p&gt;
&lt;h3 id=&quot;传送加密信息&quot;&gt;&lt;a href=&quot;#传送加密信息&quot; class=&quot;headerlink&quot; title=&quot;传送加密信息&quot;&gt;&lt;/a&gt;传送加密信息&lt;/h3&gt;&lt;p&gt;这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。&lt;/p&gt;
&lt;h3 id=&quot;服务段解密信息&quot;&gt;&lt;a href=&quot;#服务段解密信息&quot; class=&quot;headerlink&quot; title=&quot;服务段解密信息&quot;&gt;&lt;/a&gt;服务段解密信息&lt;/h3&gt;&lt;p&gt;服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。&lt;/p&gt;
&lt;h3 id=&quot;传输加密后的信息&quot;&gt;&lt;a href=&quot;#传输加密后的信息&quot; class=&quot;headerlink&quot; title=&quot;传输加密后的信息&quot;&gt;&lt;/a&gt;传输加密后的信息&lt;/h3&gt;&lt;p&gt;这部分信息是服务段用私钥加密后的信息，可以在客户端被还原&lt;/p&gt;
&lt;h3 id=&quot;客户端解密信息&quot;&gt;&lt;a href=&quot;#客户端解密信息&quot; class=&quot;headerlink&quot; title=&quot;客户端解密信息&quot;&gt;&lt;/a&gt;客户端解密信息&lt;/h3&gt;&lt;p&gt;客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPS其实是有两部分组成：HTTP + SSL/TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.
    
    </summary>
    
      <category term="好文章收集" scheme="http://python-ning.github.io/categories/%E5%A5%BD%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="https" scheme="http://python-ning.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Django(七)配置及使用富文本编辑器ckeditor</title>
    <link href="http://python-ning.github.io/2016/04/12/python_django_blog_ckeditor/"/>
    <id>http://python-ning.github.io/2016/04/12/python_django_blog_ckeditor/</id>
    <published>2016-04-12T07:00:00.000Z</published>
    <updated>2016-04-13T18:52:06.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/319037-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你想入门django的时候，一般大家都会选择搭建一个博客系统来学习django，而当你发现你写文章需要格式，需要样式，需要不仅仅是文字的时候，这时你就会需要到富文本编辑器，富文本编辑器包括kindeditor、ckeditor、uEditor等等。这里介绍一下ckeditor的配置和使用，他们大概的原理是一样的。&lt;/p&gt;
&lt;h3 id=&quot;安装django-ckeditor&quot;&gt;&lt;a href=&quot;#安装django-ckeditor&quot; class=&quot;headerlink&quot; title=&quot;安装django-ckeditor&quot;&gt;&lt;/a&gt;安装django-ckeditor&lt;/h3&gt;&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;django-ckeditor&lt;/code&gt;的下载地址：&lt;a href=&quot;https://github.com/shaunsephton/django-ckeditor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/shaunsephton/django-ckeditor&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装git 自行百度， 这里用的ubuntu14.04系统
git clone https://github.com/shaunsephton/django-ckeditor
# 打开你克隆下来的文件夹
cd django-ckeditor/
# 运行下面的命令
python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;安装Pillow&quot;&gt;&lt;a href=&quot;#安装Pillow&quot; class=&quot;headerlink&quot; title=&quot;安装Pillow&quot;&gt;&lt;/a&gt;安装Pillow&lt;/h3&gt;&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;Pillow&lt;/code&gt;是python的一个图像处理库，django-ckeditor需要依赖该库。最简单的安装方法，当然是使用pip，假设你装过pip，可以直接运行以下命令安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install Pillow
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你不了解pip，可以参照：&lt;a href=&quot;https://pypi.python.org/pypi/pip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://pypi.python.org/pypi/pip&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置你的django&quot;&gt;&lt;a href=&quot;#配置你的django&quot; class=&quot;headerlink&quot; title=&quot;配置你的django&quot;&gt;&lt;/a&gt;配置你的django&lt;/h3&gt;&lt;p&gt;要使安装好的&lt;code style=&quot;color: red&quot;&gt;django-ckeditor&lt;/code&gt;生效，你需要对你的django应用进行一系列配置。现在带大家走一遍，放轻松^_^&lt;/p&gt;
&lt;p&gt;1.在你的&lt;code style=&quot;color: red&quot;&gt;settings.py&lt;/code&gt;文件中，将ckeditor添加到&lt;code style=&quot;color: red&quot;&gt;INATALLED_APPS&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;2.在你的&lt;code style=&quot;color: red&quot;&gt;settings.py&lt;/code&gt;文件中，添加&lt;code style=&quot;color: red&quot;&gt;CKEDITOR_UPLOAD_PATH&lt;/code&gt;配置项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如，我的是
MEDIA_URL = &amp;quot;/media/&amp;quot;
MEDIA_ROOT = os.path.join(BASE_DIR, &amp;quot;media&amp;quot;)
CKEDITOR_UPLOAD_PATH = &amp;quot;article_images&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;CHEDITOR_UPLOAD_PATH&lt;/code&gt;的作用是设定你通过ckeditor所上传的文件的存放目录。需要注意的是，这是一个相对路径，它相对与你设置的的&lt;code style=&quot;color: red&quot;&gt;MEDIA_ROOT&lt;/code&gt;。&lt;code style=&quot;color: red&quot;&gt;django-ckeditor&lt;/code&gt;默认使用django的后台文件存储系统，这需要你设置好&lt;code style=&quot;color: red&quot;&gt;MEDIA_ROOT&lt;/code&gt;和&lt;code style=&quot;color: red&quot;&gt;MEDIA_URL&lt;/code&gt;，如何设置超出了本文的范围，请自行查看django的官方文档，请务必确保这两个设置项是生效的，否则你将看不到你上传的文件。&lt;/p&gt;
&lt;p&gt;比如，我上传一张名为shiguang.gif的小图片，该图片将会被存储到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/my/django/app/root/media/article_images/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在你django应用的的urls.py文件中，为ckeditor设置url：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;url(r&amp;apos;^ckeditor/&amp;apos;, include(&amp;apos;ckeditor_uploader.urls&amp;apos;)),
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，你的ckeditor已经可以在django中正常使用了。&lt;/p&gt;
&lt;p&gt;需要指出的是：在开发阶段，这样设置settings.py已经足够了。但是，到了正式部署你的应用时，你需要设置好&lt;code style=&quot;color: red&quot;&gt;STATIC_ROOT和STATIC_URL&lt;/code&gt;，并运行&lt;code style=&quot;color: red&quot;&gt;manage.py collectstatic&lt;/code&gt;命令，该命令会将ckeditor相关的静态资源拷贝到你的工程下。&lt;/p&gt;
&lt;h3 id=&quot;如何应用ckeditor&quot;&gt;&lt;a href=&quot;#如何应用ckeditor&quot; class=&quot;headerlink&quot; title=&quot;如何应用ckeditor&quot;&gt;&lt;/a&gt;如何应用ckeditor&lt;/h3&gt;&lt;p&gt;django-ckeditor提供了两个类：&lt;code style=&quot;color: red&quot;&gt;RichTextField&lt;/code&gt;和&lt;code style=&quot;color: red&quot;&gt;CKEditorWidget&lt;/code&gt;，分别用于模型和表单。内容型网站通常在后台会有一个文章发布和编辑的界面，如果你想让该界面拥有一个富文本编辑器，只需按如下方式定义你的django模型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from django.db import models
from ckeditor.fields import RichTextField

class Article(models.Model):
    content = RichTextField(&amp;apos;正文&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你在你的后台看到下图这样的界面，那么恭喜你，你初步成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/qq20140625074502.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code style=&quot;color: red&quot;&gt;RichTextField&lt;/code&gt;是一个&lt;code style=&quot;color: red&quot;&gt;TextField&lt;/code&gt;的子类，除了&lt;code style=&quot;color: red&quot;&gt;TextField&lt;/code&gt;拥有所有参数外，还有自己的参数，这些参数中，软件作者的文档中只介绍了&lt;code style=&quot;color: red&quot;&gt;config_name&lt;/code&gt;这个参数，其它的没有提及，虽然比较操蛋，但我们还是对作者贡献这个开源项目表示由衷的感谢。&lt;/p&gt;
&lt;p&gt;通过查看源代码，可以发现&lt;code style=&quot;color: red&quot;&gt;RichTextField&lt;/code&gt;有&lt;code style=&quot;color: red&quot;&gt;config_name&lt;/code&gt;、&lt;code style=&quot;color: red&quot;&gt;extra_plugins&lt;/code&gt;、&lt;code style=&quot;color: red&quot;&gt;external_plugin_resources&lt;/code&gt;三个额外的可选参数。&lt;code style=&quot;color: red&quot;&gt;extra_plugins&lt;/code&gt;我将撰写专文，尽请期待。&lt;/p&gt;
&lt;h3 id=&quot;进一步完善&quot;&gt;&lt;a href=&quot;#进一步完善&quot; class=&quot;headerlink&quot; title=&quot;进一步完善&quot;&gt;&lt;/a&gt;进一步完善&lt;/h3&gt;&lt;p&gt;追求完美的你，此刻一定有诸多不满。ckeditor最重要的，当然是头部的工具栏了，但现在你看到的工具栏比较简陋。比如，你想调整文本的对其方式，你发现找不到对应的按钮。别急，往下看。&lt;/p&gt;
&lt;p&gt;django-ckeditor作者的文档中，提到了一个配置项：&lt;code style=&quot;color: red&quot;&gt;CKEDITOR_CONFIGS&lt;/code&gt;。从作者的文档看来，似乎只要在settings.py中按如下方式配置，就可以拥有一个完整的、丰富工具栏：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CKEDITOR_CONFIGS = {
    &amp;apos;default&amp;apos;: {
        &amp;apos;toolbar&amp;apos;: &amp;apos;Full&amp;apos;,
        &amp;apos;height&amp;apos;: 300,
        &amp;apos;width&amp;apos;: 300,
    },
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你失望地发现，宽度和高度确实起作用了，可工具栏的功能还是没多页没少：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/qq20140625080916.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;怎么回事呢？如果你进行如下设置，你会发现工具栏里的按钮变少了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CKEDITOR_CONFIGS = {
    &amp;apos;default&amp;apos;: {
        &amp;apos;toolbar&amp;apos;: &amp;apos;Basic&amp;apos;
    },
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/qq20140625081523.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;看来配置项“toolbar”这个参数是生效的，那问题出在哪了？别抓狂，不是说简洁就是美吗，呵呵。不过话虽如此，咱么还是去看看源码一探究竟吧。&lt;/p&gt;
&lt;p&gt;打开如下源文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;your\python\path\Lib\site-packages\django_ckeditor_updated-4.2.8-py2.7.egg\ckeditor\widgets.py
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEFAULT_CONFIG = {
    &amp;apos;skin&amp;apos;: &amp;apos;moono&amp;apos;,
    &amp;apos;toolbar_Basic&amp;apos;: [
        [&amp;apos;Source&amp;apos;, &amp;apos;-&amp;apos;, &amp;apos;Bold&amp;apos;, &amp;apos;Italic&amp;apos;]
    ],
    &amp;apos;toolbar_Full&amp;apos;: [
        [&amp;apos;Styles&amp;apos;, &amp;apos;Format&amp;apos;, &amp;apos;Bold&amp;apos;, &amp;apos;Italic&amp;apos;, &amp;apos;Underline&amp;apos;, &amp;apos;Strike&amp;apos;, &amp;apos;SpellChecker&amp;apos;, &amp;apos;Undo&amp;apos;, &amp;apos;Redo&amp;apos;],
        [&amp;apos;Image&amp;apos;, &amp;apos;Flash&amp;apos;, &amp;apos;Table&amp;apos;, &amp;apos;HorizontalRule&amp;apos;],
        [&amp;apos;TextColor&amp;apos;, &amp;apos;BGColor&amp;apos;],
        [&amp;apos;Smiley&amp;apos;, &amp;apos;SpecialChar&amp;apos;], [&amp;apos;Source&amp;apos;],
    ],
    &amp;apos;toolbar&amp;apos;: &amp;apos;Full&amp;apos;,
    &amp;apos;height&amp;apos;: 291,
    &amp;apos;width&amp;apos;: 835,
    &amp;apos;filebrowserWindowWidth&amp;apos;: 940,
    &amp;apos;filebrowserWindowHeight&amp;apos;: 725    
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没错，问题就处在这里了。可以看到，默认的设置的确就是’toolbar’: ‘Full’,但是通过’toolbar_Full’这个key，作者阉割了工具栏的功能。&lt;/p&gt;
&lt;p&gt;找到的原因就好办了，接下来你只要在settings.py配置文件中，在&lt;code style=&quot;color: red&quot;&gt;CKEDITOR_CONFIGS&lt;/code&gt;中加入你自己需要的工具栏按钮即可：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CKEDITOR_CONFIGS = {
    &amp;apos;default&amp;apos;: {
        &amp;apos;toolbar&amp;apos;: (
            [&amp;apos;div&amp;apos;,&amp;apos;Source&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Save&amp;apos;,&amp;apos;NewPage&amp;apos;,&amp;apos;Preview&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Templates&amp;apos;], 
            [&amp;apos;Cut&amp;apos;,&amp;apos;Copy&amp;apos;,&amp;apos;Paste&amp;apos;,&amp;apos;PasteText&amp;apos;,&amp;apos;PasteFromWord&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Print&amp;apos;,&amp;apos;SpellChecker&amp;apos;,&amp;apos;Scayt&amp;apos;], 
            [&amp;apos;Undo&amp;apos;,&amp;apos;Redo&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Find&amp;apos;,&amp;apos;Replace&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;SelectAll&amp;apos;,&amp;apos;RemoveFormat&amp;apos;], 
            [&amp;apos;Form&amp;apos;,&amp;apos;Checkbox&amp;apos;,&amp;apos;Radio&amp;apos;,&amp;apos;TextField&amp;apos;,&amp;apos;Textarea&amp;apos;,&amp;apos;Select&amp;apos;,&amp;apos;Button&amp;apos;, &amp;apos;ImageButton&amp;apos;,&amp;apos;HiddenField&amp;apos;], 
            [&amp;apos;Bold&amp;apos;,&amp;apos;Italic&amp;apos;,&amp;apos;Underline&amp;apos;,&amp;apos;Strike&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Subscript&amp;apos;,&amp;apos;Superscript&amp;apos;], 
            [&amp;apos;NumberedList&amp;apos;,&amp;apos;BulletedList&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;Outdent&amp;apos;,&amp;apos;Indent&amp;apos;,&amp;apos;Blockquote&amp;apos;], 
            [&amp;apos;JustifyLeft&amp;apos;,&amp;apos;JustifyCenter&amp;apos;,&amp;apos;JustifyRight&amp;apos;,&amp;apos;JustifyBlock&amp;apos;], 
            [&amp;apos;Link&amp;apos;,&amp;apos;Unlink&amp;apos;,&amp;apos;Anchor&amp;apos;], 
            [&amp;apos;Image&amp;apos;,&amp;apos;Flash&amp;apos;,&amp;apos;Table&amp;apos;,&amp;apos;HorizontalRule&amp;apos;,&amp;apos;Smiley&amp;apos;,&amp;apos;SpecialChar&amp;apos;,&amp;apos;PageBreak&amp;apos;], 
            [&amp;apos;Styles&amp;apos;,&amp;apos;Format&amp;apos;,&amp;apos;Font&amp;apos;,&amp;apos;FontSize&amp;apos;], 
            [&amp;apos;TextColor&amp;apos;,&amp;apos;BGColor&amp;apos;], 
            [&amp;apos;Maximize&amp;apos;,&amp;apos;ShowBlocks&amp;apos;,&amp;apos;-&amp;apos;,&amp;apos;About&amp;apos;, &amp;apos;pbckcode&amp;apos;],
        ),
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，你可以注掉你不需要的功能，是丰是俭，全凭你做主！&lt;/p&gt;
&lt;p&gt;重启应用后，你可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/qq20140625083707.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/319037-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你想入门djang
    
    </summary>
    
      <category term="python" scheme="http://python-ning.github.io/categories/python/"/>
    
    
      <category term="django" scheme="http://python-ning.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>初识NoSQL</title>
    <link href="http://python-ning.github.io/2016/04/08/good_article_collect_nosql/"/>
    <id>http://python-ning.github.io/2016/04/08/good_article_collect_nosql/</id>
    <published>2016-04-08T07:00:00.000Z</published>
    <updated>2016-04-09T00:29:04.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/318044-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;/p&gt;
&lt;p&gt;NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。&lt;/p&gt;
&lt;p&gt;在现代的计算系统上每天网络上都会产生庞大的数据量。&lt;/p&gt;
&lt;p&gt;这些数据有很大一部分是由关系数据库管理系统（RDMBSs）来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。&lt;br&gt;通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。&lt;/p&gt;
&lt;h3 id=&quot;NoSQL-简史&quot;&gt;&lt;a href=&quot;#NoSQL-简史&quot; class=&quot;headerlink&quot; title=&quot;NoSQL 简史&quot;&gt;&lt;/a&gt;NoSQL 简史&lt;/h3&gt;&lt;p&gt;NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。&lt;/p&gt;
&lt;p&gt;2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。&lt;/p&gt;
&lt;p&gt;2009年在亚特兰大举行的”no:sql(east)”讨论会是一个里程碑，其口号是”select fun, profit from real_world where relational=false;”。因此，对NoSQL最普遍的解释是”非关联型的”，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。&lt;/p&gt;
&lt;p&gt;NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。&lt;/p&gt;
&lt;h3 id=&quot;关系型数据库遵循ACID规则&quot;&gt;&lt;a href=&quot;#关系型数据库遵循ACID规则&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库遵循ACID规则&quot;&gt;&lt;/a&gt;关系型数据库遵循ACID规则&lt;/h3&gt;&lt;p&gt;事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：&lt;/p&gt;
&lt;h2 id=&quot;1、A-Atomicity-原子性&quot;&gt;&lt;a href=&quot;#1、A-Atomicity-原子性&quot; class=&quot;headerlink&quot; title=&quot;1、A (Atomicity) 原子性&quot;&gt;&lt;/a&gt;1、A (Atomicity) 原子性&lt;/h2&gt;&lt;p&gt;原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。&lt;br&gt;比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。&lt;/p&gt;
&lt;h2 id=&quot;2、C-Consistency-一致性&quot;&gt;&lt;a href=&quot;#2、C-Consistency-一致性&quot; class=&quot;headerlink&quot; title=&quot;2、C (Consistency) 一致性&quot;&gt;&lt;/a&gt;2、C (Consistency) 一致性&lt;/h2&gt;&lt;p&gt;一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。&lt;br&gt;例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。&lt;/p&gt;
&lt;h2 id=&quot;3、I-Isolation-独立性&quot;&gt;&lt;a href=&quot;#3、I-Isolation-独立性&quot; class=&quot;headerlink&quot; title=&quot;3、I (Isolation) 独立性&quot;&gt;&lt;/a&gt;3、I (Isolation) 独立性&lt;/h2&gt;&lt;p&gt;所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。&lt;br&gt;比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。&lt;/p&gt;
&lt;h2 id=&quot;4、D-Durability-持久性&quot;&gt;&lt;a href=&quot;#4、D-Durability-持久性&quot; class=&quot;headerlink&quot; title=&quot;4、D (Durability) 持久性&quot;&gt;&lt;/a&gt;4、D (Durability) 持久性&lt;/h2&gt;&lt;p&gt;持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。&lt;/p&gt;
&lt;h3 id=&quot;分布式系统&quot;&gt;&lt;a href=&quot;#分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式系统&quot;&gt;&lt;/a&gt;分布式系统&lt;/h3&gt;&lt;p&gt;分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。&lt;br&gt;分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。&lt;br&gt;因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。&lt;br&gt;分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。&lt;/p&gt;
&lt;h2 id=&quot;分布式计算的优点&quot;&gt;&lt;a href=&quot;#分布式计算的优点&quot; class=&quot;headerlink&quot; title=&quot;分布式计算的优点&quot;&gt;&lt;/a&gt;分布式计算的优点&lt;/h2&gt;&lt;p&gt;可靠性（容错） ：&lt;br&gt;分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。&lt;br&gt;可扩展性：&lt;br&gt;在分布式计算系统可以根据需要增加更多的机器。&lt;br&gt;资源共享：&lt;br&gt;共享数据是必不可少的应用，如银行，预订系统。&lt;br&gt;灵活性：&lt;br&gt;由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。&lt;br&gt;更快的速度：&lt;br&gt;分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。&lt;br&gt;开放系统：&lt;br&gt;由于它是开放的系统，本地或者远程都可以访问到该服务。&lt;br&gt;更高的性能：&lt;br&gt;相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。&lt;/p&gt;
&lt;h2 id=&quot;分布式计算的缺点&quot;&gt;&lt;a href=&quot;#分布式计算的缺点&quot; class=&quot;headerlink&quot; title=&quot;分布式计算的缺点&quot;&gt;&lt;/a&gt;分布式计算的缺点&lt;/h2&gt;&lt;p&gt;故障排除： ：&lt;br&gt;故障排除和诊断问题。&lt;br&gt;软件：&lt;br&gt;更少的软件支持是分布式计算系统的主要缺点。&lt;br&gt;网络：&lt;br&gt;网络基础设施的问题，包括：传输问题，高负载，信息丢失等。&lt;br&gt;安全性：&lt;br&gt;开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。&lt;/p&gt;
&lt;h3 id=&quot;什么是NoSQL&quot;&gt;&lt;a href=&quot;#什么是NoSQL&quot; class=&quot;headerlink&quot; title=&quot;什么是NoSQL?&quot;&gt;&lt;/a&gt;什么是NoSQL?&lt;/h3&gt;&lt;p&gt;NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。&lt;br&gt;NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用NoSQL&quot;&gt;&lt;a href=&quot;#为什么使用NoSQL&quot; class=&quot;headerlink&quot; title=&quot;为什么使用NoSQL ?&quot;&gt;&lt;/a&gt;为什么使用NoSQL ?&lt;/h2&gt;&lt;p&gt;今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。&lt;/p&gt;
&lt;h3 id=&quot;RDBMS-vs-NoSQL&quot;&gt;&lt;a href=&quot;#RDBMS-vs-NoSQL&quot; class=&quot;headerlink&quot; title=&quot;RDBMS vs NoSQL&quot;&gt;&lt;/a&gt;RDBMS vs NoSQL&lt;/h3&gt;&lt;h2 id=&quot;RDBMS&quot;&gt;&lt;a href=&quot;#RDBMS&quot; class=&quot;headerlink&quot; title=&quot;RDBMS&quot;&gt;&lt;/a&gt;RDBMS&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;高度组织化结构化数据
结构化查询语言（SQL） (SQL)
数据和关系都存储在单独的表中。
数据操纵语言，数据定义语言
严格的一致性
基础事务
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;NoSQL&quot;&gt;&lt;a href=&quot;#NoSQL&quot; class=&quot;headerlink&quot; title=&quot;NoSQL&quot;&gt;&lt;/a&gt;NoSQL&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;代表着不仅仅是SQL
没有声明性查询语言
没有预定义的模式
-键 - 值对存储，列存储，文档存储，图形数据库
最终一致性，而非ACID属性
非结构化和不可预知的数据
CAP定理
高性能，高可用性和可伸缩性
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;CAP定理（CAP-theorem）&quot;&gt;&lt;a href=&quot;#CAP定理（CAP-theorem）&quot; class=&quot;headerlink&quot; title=&quot;CAP定理（CAP theorem）&quot;&gt;&lt;/a&gt;CAP定理（CAP theorem）&lt;/h2&gt;&lt;p&gt;在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:&lt;br&gt;1.一致性(Consistency) (所有节点在同一时间具有相同的数据)&lt;br&gt;2.可用性(Availability) (保证每个请求不管成功或者失败都有响应)&lt;br&gt;3.分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)&lt;br&gt;CAP理论的核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。&lt;/p&gt;
&lt;p&gt;因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：&lt;br&gt;CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。&lt;br&gt;CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。&lt;br&gt;AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/20160408111941080.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;NoSQL的优点-缺点&quot;&gt;&lt;a href=&quot;#NoSQL的优点-缺点&quot; class=&quot;headerlink&quot; title=&quot;NoSQL的优点/缺点&quot;&gt;&lt;/a&gt;NoSQL的优点/缺点&lt;/h3&gt;&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点:&quot;&gt;&lt;/a&gt;优点:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;高可扩展性
分布式计算
低成本
架构的灵活性，半结构化数据
没有复杂的关系
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点:&quot;&gt;&lt;/a&gt;缺点:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;没有标准化
有限的查询功能（到目前为止）
最终一致是不直观的程序
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;BASE&quot;&gt;&lt;a href=&quot;#BASE&quot; class=&quot;headerlink&quot; title=&quot;BASE&quot;&gt;&lt;/a&gt;BASE&lt;/h3&gt;&lt;p&gt;BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。&lt;br&gt;CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。&lt;br&gt;BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:&lt;br&gt;1.Basically Availble –基本可用&lt;br&gt;2.Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的&lt;br&gt;3.Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/20160408111956018.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/20160408112008565.png&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;谁在使用NoSQL&quot;&gt;&lt;a href=&quot;#谁在使用NoSQL&quot; class=&quot;headerlink&quot; title=&quot;谁在使用NoSQL&quot;&gt;&lt;/a&gt;谁在使用NoSQL&lt;/h3&gt;&lt;p&gt;现在已经有很多公司使用了 NoSQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Google
Facebook
Mozilla
Adobe
Foursquare
LinkedIn
Digg
McGraw-Hill Education
Vermont Public Radio
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xojjc.com1.z0.glb.clouddn.com/318044-106.jpg&quot; class=&quot;img-shadow&quot; style=&quot;display: block;margin: auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;标签：&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="好文章收集" scheme="http://python-ning.github.io/categories/%E5%A5%BD%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="NoSQL" scheme="http://python-ning.github.io/tags/NoSQL/"/>
    
  </entry>
  
</feed>
